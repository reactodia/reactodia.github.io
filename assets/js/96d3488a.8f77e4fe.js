"use strict";(self.webpackChunk_reactodia_reactodia_github_io=self.webpackChunk_reactodia_reactodia_github_io||[]).push([[53320],{16593:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>c});var t=o(77810);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}},92614:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"concepts/command-history","title":"Command History","description":"Reactodia uses a common pattern to organize changes to the diagram model into \\"commands\\" representing different atomic actions to facilitate undo/redo support.","source":"@site/docs/concepts/command-history.md","sourceDirName":"concepts","slug":"/concepts/command-history","permalink":"/docs/concepts/command-history","draft":false,"unlisted":false,"editUrl":"https://github.com/reactodia/reactodia.github.io/tree/main/docs/concepts/command-history.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docs","previous":{"title":"Event System","permalink":"/docs/concepts/event-system"},"next":{"title":"Workspace Context","permalink":"/docs/concepts/workspace-context"}}');var a=o(64922),s=o(16593);const r={sidebar_position:4},c="Command History",i={},d=[{value:"Commands and undo/redo history",id:"commands-and-undoredo-history",level:2},{value:"Command batches",id:"command-batches",level:2},{value:"How to define a new command",id:"how-to-define-a-new-command",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"command-history",children:"Command History"})}),"\n",(0,a.jsx)(n.p,{children:'Reactodia uses a common pattern to organize changes to the diagram model into "commands" representing different atomic actions to facilitate undo/redo support.'}),"\n",(0,a.jsx)(n.h2,{id:"commands-and-undoredo-history",children:"Commands and undo/redo history"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/interfaces/Command",children:(0,a.jsx)(n.code,{children:"Command"})})," interface defines an action which performs a set of changes to the Reactodia state and can be executed and reverted as needed."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["The library contains many built-in commands to manipulate the diagram model, graph authoring state or perform other effects, you can find them all at ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/#commands",children:"API > workspace > Commands"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["To execute or revert a command, the ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/interfaces/CommandHistory",children:(0,a.jsx)(n.code,{children:"CommandHistory"})})," instance from ",(0,a.jsx)(n.code,{children:"DiagramModel.history"})," should be used to be able to undo or redo it later:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function Component() {\r\n  const {model} = Reactodia.useWorkspace();\r\n\r\n  const onClick = () => {\r\n    const command = changeLinkTypeVisibility(\r\n      model, 'http://example.com/connectedTo', 'hidden'\r\n    );\r\n    model.history.execute(command);\r\n  };\r\n\r\n  const onUndo = () => {\r\n    // Later: undo or redo a command\r\n    model.history.undo();\r\n    model.history.redo();\r\n  };\r\n\r\n  // ...\r\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:'Another way to use command history is to perform state changes and register a "revert" command which is used for diagram geometry updates:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function Component() {\r\n  const {model} = Reactodia.useWorkspace();\r\n\r\n  const onMove = () => {\r\n    const restoreGeometry = Reactodia.RestoreGeometry.capture(model);\r\n    /* ... make changes to the element positions and link vertices ... */\r\n    model.history.registerToUndo(command);\r\n  };\r\n\r\n  // ...\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"command-batches",children:"Command batches"}),"\n",(0,a.jsxs)(n.p,{children:["When executing multiple commands in a sequence in cases it would be desirable to undo or redo them all at once at though they were a single atomic command. In that case it is possible to start a ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/interfaces/CommandBatch",children:(0,a.jsx)(n.code,{children:"CommandBatch"})})," via ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/interfaces/CommandHistory#startbatch",children:(0,a.jsx)(n.code,{children:"CommandHistory.startBatch()"})}),", execute the commands and store the batch, so a single command is added to the history:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function Component() {\r\n  const {model} = Reactodia.useWorkspace();\r\n  const {canvas} = Reactodia.useCanvas();\r\n\r\n  const onAddElements = (\r\n    target: Reactodia.Element,\r\n    iris: readonly Reactodia.ElementIri[]\r\n  ) => {\r\n    const batch = model.history.startBatch('Adding multiple elements');\r\n\r\n    for (const iri of iris) {\r\n      // Some methods implicitly add commands to the history,\r\n      // i.e. to the active batch if any\r\n      const element = model.createElement(iri);\r\n\r\n      // In other cases the command needs to be executed explicitly\r\n      batch.history.execute(setElementState(element, {'my:custom:state': 42}));\r\n    }\r\n\r\n    batch.store();\r\n  };\r\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It is also possible to discard a batch instead of storing it with ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/interfaces/CommandBatch#discard",children:(0,a.jsx)(n.code,{children:"CommandBatch.discard()"})})," to avoid putting the commands in the history in the first place."]}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"Starting a new batch when there is an active command batch already causes the new batch to become nested, which allows to use operations creating command batches as part of a larger operation having its own top-level batch."})}),"\n",(0,a.jsx)(n.h2,{id:"how-to-define-a-new-command",children:"How to define a new command"}),"\n",(0,a.jsxs)(n.p,{children:["While it is possible to implement ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/interfaces/Command",children:(0,a.jsx)(n.code,{children:"Command"})})," interface directly, the library provides a ",(0,a.jsx)(n.a,{href:"/docs/api/workspace/namespaces/Command",children:"utility namespace"})," with the same name to simplify the process."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/docs/api/workspace/namespaces/Command/functions/create",children:(0,a.jsx)(n.code,{children:"Command.create()"})})," defines a command from a callback which returns the reverse command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function exchangeElementPositions(\r\n  first: Reactodia.ElementElement,\r\n  second: Reactodia.ElementElement\r\n): Command {\r\n  return Command.create('Exchange element positions', () => {\r\n    const position = first.position;\r\n    first.setPosition(second.position);\r\n    second.setPosition(position);\r\n    return exchangeElementPositions(first, second);\r\n  });\r\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/docs/api/workspace/namespaces/Command/functions/compound",children:(0,a.jsx)(n.code,{children:"Command.compound()"})})," defines a command from a sequence of other commands similar to using a command batch:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function resetElementStateForAll(\r\n  elements: readonly Reactodia.ElementElement[]\r\n): Command {\r\n  const commands = elements.map(el => Reactodia.setElementState(el, undefined));\r\n  return Command.compound('Reset state for elements', commands);\r\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/docs/api/workspace/namespaces/Command/functions/effect",children:(0,a.jsx)(n.code,{children:"Command.effect()"})}),' defines a command which runs only after it executed in "forward" direction but skipped on revert:']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"function logAsCommand(message: string): Command {\r\n  return Command.effect('Log a message', () => console.log(message));\r\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}}}]);