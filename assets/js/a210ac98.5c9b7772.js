"use strict";(self.webpackChunk_reactodia_reactodia_github_io=self.webpackChunk_reactodia_reactodia_github_io||[]).push([[67514],{11340:(e,r,n)=>{n.r(r),n.d(r,{Reactodia:()=>t});var t=n(96333)},15214:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>u,contentTitle:()=>c,default:()=>g,frontMatter:()=>p,metadata:()=>t,toc:()=>y});const t=JSON.parse('{"id":"examples/graph-authoring","title":"Graph Authoring","description":"Example demonstrating visual graph authoring capabilities on in-memory RDF graph data.","source":"@site/docs/examples/graph-authoring.mdx","sourceDirName":"examples","slug":"/examples/graph-authoring","permalink":"/docs/examples/graph-authoring","draft":false,"unlisted":false,"editUrl":"https://github.com/reactodia/reactodia.github.io/tree/main/docs/examples/graph-authoring.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docs","previous":{"title":"Style Customization","permalink":"/docs/examples/style-customization"},"next":{"title":"SPARQL Navigator","permalink":"/docs/examples/sparql"}}');var a=n(64922),o=n(16593),i=n(46720);n(43946);const s="import * as React from 'react';\r\nimport * as Reactodia from '@reactodia/workspace';\r\nimport * as N3 from 'n3';\r\n\r\nimport { ExampleMetadataProvider, ExampleValidationProvider } from './ExampleMetadata';\r\nimport { ExampleToolbarMenu } from './ExampleCommon';\r\n\r\nconst Layouts = Reactodia.defineLayoutWorker(() => new Worker(\r\n  new URL('@reactodia/workspace/layout.worker', import.meta.url)\r\n));\r\n\r\ntype TurtleDataSource =\r\n  | { type: 'url'; url: string }\r\n  | { type: 'data'; data: string };\r\n\r\nexport function PlaygroundGraphAuthoring() {\r\n  const {defaultLayout} = Reactodia.useWorker(Layouts);\r\n\r\n  const [dataSource, setDataSource] = React.useState<TurtleDataSource>({\r\n    type: 'url',\r\n    url: 'https://reactodia.github.io/resources/orgOntology.ttl',\r\n  });\r\n\r\n  const {onMount} = Reactodia.useLoadedWorkspace(async ({context, signal}) => {\r\n    const {model, editor, getCommandBus, performLayout} = context;\r\n    editor.setAuthoringMode(true);\r\n\r\n    let turtleData: string;\r\n    if (dataSource.type === 'url') {\r\n      const response = await fetch(dataSource.url, {signal});\r\n      turtleData = await response.text();\r\n    } else {\r\n      turtleData = dataSource.data;\r\n    }\r\n\r\n    const dataProvider = new Reactodia.RdfDataProvider();\r\n    try {\r\n      dataProvider.addGraph(new N3.Parser().parse(turtleData));\r\n    } catch (err) {\r\n      throw new Error('Error parsing RDF graph data', {cause: err});\r\n    }\r\n\r\n    await model.importLayout({dataProvider, signal});\r\n\r\n    if (dataSource.type === 'url') {\r\n      const elements = [\r\n        model.createElement('http://www.w3.org/ns/org#Organization'),\r\n        model.createElement('http://www.w3.org/ns/org#FormalOrganization'),\r\n        model.createElement('http://www.w3.org/ns/org#hasMember'),\r\n        model.createElement('http://www.w3.org/ns/org#hasSubOrganization'),\r\n        model.createElement('http://www.w3.org/ns/org#subOrganizationOf'),\r\n        model.createElement('http://www.w3.org/ns/org#unitOf'),\r\n      ];\r\n      await Promise.all([\r\n        model.requestElementData(elements.map(el => el.iri)),\r\n        model.requestLinks(),\r\n      ]);\r\n      await performLayout({signal});\r\n    } else {\r\n      getCommandBus(Reactodia.UnifiedSearchTopic)\r\n        .trigger('focus', {sectionKey: 'elementTypes'});\r\n    }\r\n  }, [dataSource]);\r\n\r\n  const [metadataProvider] = React.useState(() => new ExampleMetadataProvider());\r\n  const [validationProvider] = React.useState(() => new ExampleValidationProvider());\r\n  const [renameLinkProvider] = React.useState(() => new RenameSubclassOfProvider());\r\n\r\n  return (\r\n    <Reactodia.Workspace ref={onMount}\r\n      defaultLayout={defaultLayout}\r\n      metadataProvider={metadataProvider}\r\n      validationProvider={validationProvider}\r\n      renameLinkProvider={renameLinkProvider}>\r\n      <Reactodia.DefaultWorkspace\r\n        menu={\r\n          <>\r\n            <ToolbarActionOpenTurtleGraph onOpen={setDataSource} />\r\n            <ExampleToolbarMenu />\r\n          </>\r\n        }\r\n        visualAuthoring={{\r\n          inputResolver: (property, inputProps) => property === 'http://www.w3.org/2000/01/rdf-schema#comment'\r\n            ? <Reactodia.FormInputList {...inputProps} valueInput={MultilineTextInput} />\r\n            : undefined,\r\n        }}\r\n      />\r\n    </Reactodia.Workspace>\r\n  );\r\n}\r\n\r\nclass RenameSubclassOfProvider extends Reactodia.RenameLinkToLinkStateProvider {\r\n  override canRename(link: Reactodia.Link): boolean {\r\n      return link.typeId === 'http://www.w3.org/2000/01/rdf-schema#subClassOf';\r\n  }\r\n}\r\n\r\nfunction MultilineTextInput(props: Reactodia.FormInputSingleProps) {\r\n  return <Reactodia.FormInputText {...props} multiline />;\r\n}\r\n\r\nfunction ToolbarActionOpenTurtleGraph(props: {\r\n  onOpen: (dataSource: TurtleDataSource) => void;\r\n}) {\r\n  const {onOpen} = props;\r\n  return (\r\n    <Reactodia.ToolbarActionOpen\r\n      fileAccept='.ttl'\r\n      onSelect={async file => {\r\n        const turtleText = await file.text();\r\n        onOpen({type: 'data', data: turtleText});\r\n      }}>\r\n      Load RDF (Turtle) data\r\n    </Reactodia.ToolbarActionOpen>\r\n  );\r\n}\r\n";var l=n(43558),d=n(98576);const p={sidebar_position:5},c="Graph Authoring",u={},y=[];function m(e){const r={a:"a",admonition:"admonition",h1:"h1",header:"header",p:"p",...(0,o.R)(),...e.components},{Details:n}=r;return n||function(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"graph-authoring",children:"Graph Authoring"})}),"\n",(0,a.jsxs)(r.p,{children:["Example demonstrating ",(0,a.jsx)(r.a,{href:"/docs/concepts/graph-authoring",children:"visual graph authoring"})," capabilities on in-memory RDF graph data."]}),"\n",(0,a.jsx)(r.admonition,{type:"info",children:(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"/playground/graph-authoring",children:"\u25b6\ufe0e Open live demo"})})}),"\n","\n",(0,a.jsx)(i.A,{language:"tsx",title:"/src/examples/PlaygroundGraphAuthoring.tsx",showLineNumbers:!0,children:s}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"ExampleMetadata.ts"}),(0,a.jsx)(i.A,{language:"tsx",title:"/src/examples/ExampleMetadata.ts",showLineNumbers:!0,children:l})]}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"ExampleCommon.tsx"}),(0,a.jsx)(i.A,{language:"tsx",title:"/src/examples/ExampleCommon.tsx",showLineNumbers:!0,children:d})]})]})}function g(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},43558:e=>{e.exports="import * as Reactodia from '@reactodia/workspace';\r\n\r\nconst owl = vocabulary('http://www.w3.org/2002/07/owl#', [\r\n  'Class',\r\n  'AnnotationProperty',\r\n  'DatatypeProperty',\r\n  'ObjectProperty',\r\n]);\r\n\r\nconst rdfs = vocabulary('http://www.w3.org/2000/01/rdf-schema#', [\r\n  'comment',\r\n  'domain',\r\n  'range',\r\n  'seeAlso',\r\n  'subClassOf',\r\n  'subPropertyOf',\r\n]);\r\n\r\nconst SIMULATED_DELAY: number = 50; /* ms */\r\n\r\nexport class ExampleMetadataProvider extends Reactodia.BaseMetadataProvider {\r\n  private readonly propertyTypes = [owl.AnnotationProperty, owl.DatatypeProperty, owl.ObjectProperty];\r\n  private readonly editableTypes = new Set([owl.Class, ...this.propertyTypes]);\r\n  private readonly editableRelations = new Set<Reactodia.LinkTypeIri>([rdfs.domain, rdfs.range]);\r\n  private readonly literalLanguages: ReadonlyArray<string> = ['de', 'en', 'es', 'ru', 'zh'];\r\n\r\n  constructor() {\r\n    super({\r\n      getLiteralLanguages: () => this.literalLanguages,\r\n      createEntity: async (type, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n        const random32BitDigits = Math.floor((1 + Math.random()) * 0x100000000).toString(16).substring(1);\r\n        const typeLabel = Reactodia.Rdf.getLocalName(type) ?? 'Entity';\r\n        return {\r\n          id: `${type}_${random32BitDigits}`,\r\n          types: [type],\r\n          properties: {\r\n            [Reactodia.rdfs.label]: [\r\n              Reactodia.Rdf.DefaultDataFactory.literal(`New ${typeLabel}`)\r\n            ]\r\n          },\r\n        };\r\n      },\r\n      createRelation: async (source, target, linkType, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n        return {\r\n          sourceId: source.id,\r\n          targetId: target.id,\r\n          linkTypeId: linkType,\r\n          properties: {},\r\n        };\r\n      },\r\n      canConnect: async (source, target, linkType, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n\r\n        const connections: Reactodia.MetadataCanConnect[] = [];\r\n        const addConnections = (\r\n          types: readonly Reactodia.ElementTypeIri[],\r\n          allOutLinks: readonly Reactodia.LinkTypeIri[],\r\n          allInLinks: readonly Reactodia.LinkTypeIri[]\r\n        ) => {\r\n          const outLinks = linkType\r\n            ? allOutLinks.filter(type => type === linkType)\r\n            : allOutLinks;\r\n          const inLinks = linkType\r\n            ? allInLinks.filter(type => type === linkType)\r\n            : allInLinks;\r\n          if (types.length > 0 && (outLinks.length > 0 || inLinks.length > 0)) {\r\n            connections.push({ targetTypes: new Set(types), outLinks, inLinks });\r\n          }\r\n        };\r\n\r\n        if (hasType(source, owl.Class)) {\r\n          if (hasType(target, owl.Class)) {\r\n            addConnections([owl.Class], [rdfs.subClassOf], [rdfs.subClassOf]);\r\n          }\r\n\r\n          const targetPropertyTypes = this.propertyTypes.filter(type => hasType(target, type));\r\n          if (targetPropertyTypes.length > 0) {\r\n            addConnections(targetPropertyTypes, [], [rdfs.domain, rdfs.range]);\r\n          }\r\n        }\r\n\r\n        const sourcePropertyTypes = this.propertyTypes.filter(type => hasType(source, type));\r\n        if (sourcePropertyTypes.length > 0) {\r\n          for (const type of sourcePropertyTypes) {\r\n            if (hasType(target, type)) {\r\n              addConnections([type], [rdfs.subPropertyOf], [rdfs.subPropertyOf]);\r\n            }\r\n          }\r\n\r\n          if (hasType(target, owl.Class)) {\r\n            addConnections([owl.Class], [rdfs.domain, rdfs.range], []);\r\n          }\r\n        }\r\n\r\n        return connections;\r\n      },\r\n      canModifyEntity: async (entity, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n        const editable = entity.types.some(type => this.editableTypes.has(type));\r\n        return {\r\n          canChangeIri: entity.types.includes(owl.Class),\r\n          canEdit: editable,\r\n          canDelete: editable,\r\n        };\r\n      },\r\n      canModifyRelation: async (link, source, target, options) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal: options.signal});\r\n        switch (link.linkTypeId) {\r\n          case rdfs.domain:\r\n          case rdfs.range:\r\n          case rdfs.subClassOf:\r\n          case rdfs.subPropertyOf: {\r\n            return {\r\n              canChangeType: true,\r\n              canEdit: this.editableRelations.has(link.linkTypeId),\r\n              canDelete: true,\r\n            };\r\n          }\r\n          default: {\r\n            return {};\r\n          }\r\n        }\r\n      },\r\n      getEntityShape: async (types, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n        const properties = new Map<Reactodia.PropertyTypeIri, Reactodia.MetadataPropertyShape>();\r\n        if (types.some(type => this.editableTypes.has(type))) {\r\n          properties.set(rdfs.comment, {\r\n            valueShape: {termType: 'Literal'},\r\n          });\r\n          properties.set(Reactodia.rdfs.label, {\r\n            valueShape: {termType: 'Literal'},\r\n          });\r\n          properties.set(Reactodia.schema.thumbnailUrl, {\r\n            valueShape: {termType: 'NamedNode'},\r\n            maxCount: 1,\r\n          });\r\n          properties.set(rdfs.seeAlso, {\r\n            valueShape: {termType: 'NamedNode'},\r\n          });\r\n        }\r\n        return {properties};\r\n      },\r\n      getRelationShape: async (linkType, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n        const properties = new Map<Reactodia.PropertyTypeIri, Reactodia.MetadataPropertyShape>();\r\n        if (this.editableRelations.has(linkType)) {\r\n          properties.set(rdfs.comment, {\r\n            valueShape: {termType: 'Literal'},\r\n          });\r\n        }\r\n        return {properties};\r\n      },\r\n      filterConstructibleTypes: async (types, {signal}) => {\r\n        await Reactodia.delay(SIMULATED_DELAY, {signal});\r\n        return new Set(Array.from(types).filter(type => this.editableTypes.has(type)));\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport class ExampleValidationProvider implements Reactodia.ValidationProvider {\r\n  async validate(\r\n    event: Reactodia.ValidationEvent\r\n  ): Promise<Reactodia.ValidationResult> {\r\n    const items: Array<Reactodia.ValidatedElement | Reactodia.ValidatedLink> = [];\r\n\r\n    if (event.target.types.includes(owl.Class)) {\r\n      event.state.links.forEach(e => {\r\n        if (e.type === 'relationAdd' && e.data.sourceId === event.target.id) {\r\n          items.push({\r\n            type: 'link',\r\n            target: e.data,\r\n            severity: 'error',\r\n            message: 'Cannot add any new link from a Class',\r\n          });\r\n          items.push({\r\n            type: 'element',\r\n            target: event.target.id,\r\n            severity: 'warning',\r\n            message: `Cannot create <${e.data.linkTypeId}> link from a Class`,\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    if (\r\n      event.state.elements.has(event.target.id) &&\r\n      event.target.types.includes(owl.ObjectProperty)\r\n    ) {\r\n      if (!event.outboundLinks.some(link => link.linkTypeId === rdfs.subPropertyOf)) {\r\n        items.push({\r\n          type: 'element',\r\n          target: event.target.id,\r\n          severity: 'info',\r\n          message: 'It might be a good idea to make the property a sub-property of another',\r\n        });\r\n      }\r\n    }\r\n\r\n    for (const link of event.outboundLinks) {\r\n      const {[rdfs.comment]: comments} = link.properties;\r\n      if (comments && !comments.every(comment => comment.termType === 'Literal' && comment.language)) {\r\n        items.push({\r\n          type: 'link',\r\n          target: link,\r\n          severity: 'error',\r\n          message: 'rdfs:comment value should have a language',\r\n        });\r\n      }\r\n    }\r\n\r\n    await Reactodia.delay(SIMULATED_DELAY, {signal: event.signal});\r\n    return {items};\r\n  }\r\n}\r\n\r\ntype VocabularyKeyType<K extends string> =\r\n  K extends Capitalize<K>\r\n    ? Reactodia.ElementTypeIri\r\n    : Reactodia.LinkTypeIri & Reactodia.PropertyTypeIri;\r\n\r\ntype Vocabulary<Keys extends string[]> = {\r\n  readonly [K in Keys[number]]: VocabularyKeyType<K>;\r\n};\r\n\r\nfunction vocabulary<const Keys extends string[]>(prefix: string, keys: Keys): Vocabulary<Keys> {\r\n  const result: { [key: string]: string } = Object.create(null);\r\n  for (const key of keys) {\r\n    result[key] = prefix + key;\r\n  }\r\n  return result as Vocabulary<Keys>;\r\n}\r\n\r\nfunction hasType(model: Reactodia.ElementModel | undefined, type: Reactodia.ElementTypeIri) {\r\n  return Boolean(!model || model.types.includes(type));\r\n}\r\n"},64685:(e,r,n)=>{n.d(r,{A:()=>a});var t=n(77810);const a={React:t,...t,get Reactodia(){const{Reactodia:e}=n(11340);return e},get N3(){const{N3:e}=n(90211);return e},get Layouts(){const{Reactodia:e}=n(11340);return e.defineLayoutWorker((()=>new Worker(new URL(n.p+n.u(99682),n.b))))}}},90211:(e,r,n)=>{n.r(r),n.d(r,{N3:()=>t});var t=n(56881)},98576:e=>{e.exports="import * as React from 'react';\r\nimport * as Reactodia from '@reactodia/workspace';\r\nimport { saveAs } from 'file-saver';\r\n\r\nexport function ExampleToolbarMenu() {\r\n  const {model, editor, overlay} = Reactodia.useWorkspace();\r\n  return (\r\n    <>\r\n      <Reactodia.ToolbarActionOpen\r\n        hotkey='Mod+O'\r\n        fileAccept='.json'\r\n        onSelect={async file => {\r\n          const preloadedElements = new Map<Reactodia.ElementIri, Reactodia.ElementModel>();\r\n          for (const element of model.elements) {\r\n            for (const data of Reactodia.iterateEntitiesOf(element)) {\r\n              preloadedElements.set(data.id, data);\r\n            }\r\n          }\r\n\r\n          const task = overlay.startTask({title: 'Importing a layout from file'});\r\n          try {\r\n            const json = await file.text();\r\n            const diagramLayout = JSON.parse(json);\r\n            await model.importLayout({\r\n              dataProvider: model.dataProvider,\r\n              diagram: diagramLayout,\r\n              preloadedElements,\r\n              validateLinks: true,\r\n            });\r\n          } catch (err) {\r\n            task.setError(new Error(\r\n              'Failed to load specified file with a diagram layout.',\r\n              {cause: err}\r\n            ));\r\n          } finally {\r\n            task.end();\r\n          }\r\n        }}>\r\n        Open diagram from file\r\n      </Reactodia.ToolbarActionOpen>\r\n      <Reactodia.ToolbarActionSave mode='layout'\r\n        hotkey='Mod+S'\r\n        onSelect={() => {\r\n          const diagramLayout = model.exportLayout();\r\n          const layoutString = JSON.stringify(diagramLayout);\r\n          const blob = new Blob([layoutString], {type: 'application/json'});\r\n          const timestamp = new Date().toISOString().replaceAll(/[Z\\s:-]/g, '');\r\n          saveAs(blob, `reactodia-diagram-${timestamp}.json`);\r\n        }}>\r\n        Save diagram to file\r\n      </Reactodia.ToolbarActionSave>\r\n      {editor.inAuthoringMode ? (\r\n        <Reactodia.ToolbarActionSave mode='authoring'\r\n          onSelect={() => {\r\n            const state = editor.authoringState;\r\n            console.log('Authoring state:', state);\r\n            alert('Please check browser console for result');\r\n          }}>\r\n          Persist changes to data\r\n        </Reactodia.ToolbarActionSave>\r\n      ) : null}\r\n      <Reactodia.ToolbarActionClearAll />\r\n      <Reactodia.ToolbarActionExport kind='exportRaster' />\r\n      <Reactodia.ToolbarActionExport kind='exportSvg' />\r\n      <Reactodia.ToolbarActionExport kind='print' hotkey='Mod+P' />\r\n    </>\r\n  );\r\n}\r\n"}}]);