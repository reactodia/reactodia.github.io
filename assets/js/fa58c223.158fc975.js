"use strict";(self.webpackChunk_reactodia_reactodia_github_io=self.webpackChunk_reactodia_reactodia_github_io||[]).push([[22453],{16593:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var s=t(77810);const r={},o=s.createContext(r);function c(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(o.Provider,{value:n},e.children)}},92822:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"concepts/event-system","title":"Event System","description":"Reactodia uses a lightweight EventEmitter-like publish-subscribe mechanism to connect different components and observe changes to the state.","source":"@site/docs/concepts/event-system.md","sourceDirName":"concepts","slug":"/concepts/event-system","permalink":"/docs/concepts/event-system","draft":false,"unlisted":false,"editUrl":"https://github.com/reactodia/reactodia.github.io/tree/main/docs/concepts/event-system.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Event System"},"sidebar":"docs","previous":{"title":"Data Provider","permalink":"/docs/concepts/data-provider"},"next":{"title":"Command History","permalink":"/docs/concepts/command-history"}}');var r=t(64922),o=t(16593);const c={sidebar_position:3,title:"Event System"},a="Publish-Subscribe Event System",i={},d=[{value:"Observing events",id:"observing-events",level:2},{value:"Using React hooks to listen to events",id:"using-react-hooks-to-listen-to-events",level:3},{value:"Making an observable",id:"making-an-observable",level:2},{value:"Using command bus to communicate with components",id:"command-bus",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"publish-subscribe-event-system",children:"Publish-Subscribe Event System"})}),"\n",(0,r.jsxs)(n.p,{children:["Reactodia uses a lightweight ",(0,r.jsx)(n.a,{href:"https://nodejs.org/docs/latest/api/events.html",children:(0,r.jsx)(n.code,{children:"EventEmitter"})}),"-like publish-subscribe mechanism to connect different components and observe changes to the state."]}),"\n",(0,r.jsx)(n.h2,{id:"observing-events",children:"Observing events"}),"\n",(0,r.jsxs)(n.p,{children:["An observable instance in the library typically expose an ",(0,r.jsx)(n.code,{children:"events"})," property implementing an ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/interfaces/Events",children:(0,r.jsx)(n.code,{children:"Events"})})," interface. Listeners can be attached directly to the ",(0,r.jsx)(n.code,{children:"Events"})," or subscribed via ",(0,r.jsx)(n.code,{children:"EventObserver"})," to make it easy to unsubscribe:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const {model} = Reactodia.useWorkspace();\r\n\r\nconst onChangeSelection = () => {\r\n  console.log('New selection:', model.selection);\r\n};\r\n// Subscribe to the selection change event\r\nmodel.events.on('changeSelection', onChangeSelection);\r\n// Unsubscribe, must pass the same callback\r\nmodel.events.off('changeSelection', onChangeSelection);\r\n\r\nconst observer = new Reactodia.EventObserver();\r\n// Subscribe to the language change event\r\nobserver.listen(model.events, 'changeLanguage', ({previous}) => {\r\n  console.log(`Changed language from ${previous} to ${model.language}`);\r\n});\r\n// Unsubscribe from all events added via listen() by the observer\r\nobserver.stopListening();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is possible to listen for all events on an instance by using ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/interfaces/Events#onany",children:(0,r.jsx)(n.code,{children:"Events.onAny()"})})," or ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/classes/EventObserver#listenany",children:(0,r.jsx)(n.code,{children:"EventObserver.listenAny()"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function Component() {\r\n  const {model} = React.useWorkspace();\r\n  React.useEffect(() => {\r\n    const element = model.getElement(elementId);\r\n    const observer = new Reactodia.EventObserver();\r\n    observer.listenAny(element, ({data}) => {\r\n      if (data.requestedFocus || data.requestedRedraw) {\r\n        console.log('Element requested something');\r\n      }\r\n    });\r\n    return () => observer.stopListening();\r\n  }, [elementId]);\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-react-hooks-to-listen-to-events",children:"Using React hooks to listen to events"}),"\n",(0,r.jsxs)(n.p,{children:["In case of change-like events it is recommended to use ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/functions/useObservedProperty",children:(0,r.jsx)(n.code,{children:"useObservedProperty()"})})," to observe current value:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const {editor} = Reactodia.useWorkspace();\r\n// Subscribe to editor.authoringState changes\r\nconst authoringState = Reactodia.useObservedProperty(\r\n  editor.events, 'changeAuthoringState', () => editor.authoringState\r\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Alternatively it is possible to use a combination of ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/functions/useEventStore",children:(0,r.jsx)(n.code,{children:"useEventStore()"})})," and either a React built-in ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/useSyncExternalStore",children:(0,r.jsx)(n.code,{children:"useSyncExternalStore()"})})," or a compatibility shim ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/functions/useSyncStore",children:(0,r.jsx)(n.code,{children:"Reactodia.useSyncStore()"})})," for more control over subscription:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { useSyncExternalStore } from 'react';\r\n\r\nfunction Component() {\r\n  const {editor} = Reactodia.useWorkspace();\r\n  const eventStore = Reactodia.useEventStore(\r\n    editor.events, 'changeAuthoringState'\r\n  );\r\n  const debouncedStore = Reactodia.useFrameDebouncedStore(eventStore);\r\n  const authoringState = useSyncExternalStore(\r\n    debouncedStore, () => editor.authoringState\r\n  );\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the above example, ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/functions/useFrameDebouncedStore",children:(0,r.jsx)(n.code,{children:"Reactodia.useFrameDebouncedStore()"})})," hook is used to debounce React component updates due to triggered events from the event store to only once each rendered frame based on ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame",children:(0,r.jsx)(n.code,{children:"requestAnimationFrame()"})}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"making-an-observable",children:"Making an observable"}),"\n",(0,r.jsxs)(n.p,{children:["To create an observable instance it would be enough to implement the ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/interfaces/Events",children:(0,r.jsx)(n.code,{children:"Events"})})," interface. An easiest way to do it would be to use ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/classes/EventSource",children:(0,r.jsx)(n.code,{children:"EventSource"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Declare event types\r\ninterface MyObservableEvents {\r\n  changeTitle: Reactodia.PropertyChange<MyObservableThing, string>;\r\n  notification: {\r\n    readonly status: 'normal' | 'error';\r\n    readonly message: string;\r\n  };\r\n}\r\n\r\nclass MyObservableThing {\r\n  // Create an event source\r\n  private readonly source = new EventSource<MyObservableEvents>();\r\n  readonly events: Events<MyObservableEvents> = this.source;\r\n\r\n  // ...\r\n\r\n  setTitle(title: string) {\r\n    const previous = this._title;\r\n    if (previous !== title) {\r\n      this._title = title;\r\n      // Trigger change event\r\n      this.source.trigger('changeTitle', {source: this, previous});\r\n    }\r\n  }\r\n\r\n  private handleNotification(status: 'normal' | 'error', message: string): void {\r\n    // Trigger another event\r\n    this.source.trigger('notification', {status, message});\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/api/workspace/classes/EventSource",children:(0,r.jsx)(n.code,{children:"EventSource"})})," implements ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/interfaces/EventTrigger",children:(0,r.jsx)(n.code,{children:"EventTrigger"})})," interface which can be used as a separate type, e.g. a combination of ",(0,r.jsx)(n.code,{children:"Events<T> & EventTrigger<T>"}),' can be used as an "event bus" to trigger and listen for events at the same time.']})}),"\n",(0,r.jsx)(n.h2,{id:"command-bus",children:"Using command bus to communicate with components"}),"\n",(0,r.jsxs)(n.p,{children:["Reactodia workspace context provides means for components to communicate with each other through an event bus (",(0,r.jsx)(n.strong,{children:"command bus"}),"). It is possible to get a shared command bus instance by calling ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/interfaces/WorkspaceContext",children:(0,r.jsx)(n.code,{children:"WorkspaceContext.getCommandBus()"})})," with a defined ",(0,r.jsx)(n.a,{href:"/docs/api/workspace/classes/CommandBusTopic",children:(0,r.jsx)(n.code,{children:"CommandBusTopic"})})," constant:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Define possible commands for a bus\r\ninterface MyCommands {\r\n  showAlert: { readonly message: string };\r\n}\r\n// Define a command bus topic\r\nconst MyTopic = CommandBusTopic.define<MyCommands>();\r\n\r\n// Observe commands in a component\r\nfunction MyComponent() {\r\n  const {getCommandBus} = Reactodia.useWorkspace();\r\n\r\n  const commands = getCommandBus(MyTopic);\r\n  React.useEffect(() => {\r\n    // Subscribe for a command in a particular topic\r\n    const listener = new Reactodia.EventObserver();\r\n    listener.listen(commands, 'showAlert', ({message}) => {\r\n      showAlert(message);\r\n    });\r\n    return () => listener.stopListening();\r\n  }, [commands]);\r\n  // ...\r\n}\r\n\r\n// Trigger commands from any other place\r\nfunction OtherComponent() {\r\n  const {getCommandBus} = Reactodia.useWorkspace();\r\n\r\n  const onClick = () => {\r\n    getCommandBus(MyTopic)\r\n      .trigger('showAlert', {message: 'Hello!'});\r\n  };\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each Reactodia ",(0,r.jsx)(n.a,{href:"/docs/components/workspace",children:(0,r.jsx)(n.code,{children:"<Workspace />"})})," instance maintains its own command buses for each topic not connected to other workspaces in any way."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);